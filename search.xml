<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>修改日志</title>
    <url>/2022/11/10/%E4%BF%AE%E6%94%B9%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="美化">美化</h1>
<h2 id="更改页面透明度">更改页面透明度</h2>
<p><code>themes\next\source\css\variables\base.styl</code>53行
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$body-bg-color                = white;</span><br><span class="line">$content-bg-color-dark        = $black-dim;</span><br></pre></td></tr></table></figure> 修改为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$body-bg-color                = rgba(255,255,255,0.7);</span><br><span class="line">$content-bg-color-dark        = rgba(60,60,60,0.75);</span><br></pre></td></tr></table></figure> ## 背景颜色
<code>themes\next\source\css\variables\Pisces.styl</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$body-bg-color                = #f5f7f9;</span><br></pre></td></tr></table></figure>
更改为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$body-bg-color                = rgba(250,210,225,0.2);</span><br></pre></td></tr></table></figure> 以图片做背景后无效了。 ## 圆角
<code>source\_data\variables.styl</code></p>
<h1 id="功能增加">功能增加</h1>
<h2 id="最近文章">最近文章</h2>
<p><code>themes\next\_config.yml</code>31行之后增加 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">recent_posts:</span><br><span class="line"># 块标题</span><br><span class="line">  title: 最近文章</span><br><span class="line"># 图标</span><br><span class="line">  icon: fa fa-history</span><br><span class="line"># 最多多少文章链接</span><br><span class="line">  max_count: 5</span><br></pre></td></tr></table></figure>
<code>source\_data\sidebar.njk</code>，<code>source\_data\styles.styl</code></p>
]]></content>
  </entry>
  <entry>
    <title>LaTeX 代码备忘</title>
    <url>/2022/11/09/LaTeX%E4%BB%A3%E7%A0%81%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h1 id="数学符号">数学符号</h1>
<h2 id="括号矩阵相关">括号、矩阵相关</h2>
<ol type="1">
<li><p>花括号 <span class="math inline">\(\lbrace A
\rbrace\)</span></p></li>
<li><p>大括号 注意，在MathJax，“\”需要替换为“\\”。 <span
class="math display">\[
m_{ij}=\left\lbrace
\begin{aligned}
     1 &amp; , &amp; \text{if }(a_i, b_j)\in R, \\\\
     0 &amp; , &amp; \text{if }(a_i, b_j)\notin R.
\end{aligned}
\right.
\]</span></p></li>
<li><p>矩阵 <span class="math display">\[
\begin{matrix} 0 &amp; 1 \\\\ 1 &amp; 0 \end{matrix}
\quad
\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0 \end{pmatrix}
\quad
\begin{bmatrix} 0 &amp; -1 \\\\ 1 &amp; 0 \end{bmatrix}
\quad
\begin{Bmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \end{Bmatrix}
\quad
\begin{vmatrix} a &amp; b \\\\ c &amp; d \end{vmatrix}
\quad
\begin{Vmatrix} i &amp; 0 \\\\ 0 &amp; -i \end{Vmatrix}
\]</span></p></li>
</ol>
<h2 id="微积分">微积分</h2>
<ol type="1">
<li>无穷 <span class="math inline">\(\infty\)</span></li>
</ol>
<h2 id="双目运算符">双目运算符</h2>
<ol type="1">
<li>关系运算符</li>
</ol>
<table>
<tbody>
<tr class="odd">
<td><span class="math inline">\(≤\)</span></td>
<td></td>
<td><span class="math inline">\(≠\)</span></td>
<td></td>
<td><span class="math inline">\(≈\)</span></td>
<td></td>
<td><span class="math inline">\(∣\)</span></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(≥\)</span></td>
<td></td>
<td><span class="math inline">\(≐\)</span></td>
<td></td>
<td><span class="math inline">\(≅\)</span></td>
<td></td>
<td><span class="math inline">\(∥\)</span></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(≪\)</span></td>
<td></td>
<td><span class="math inline">\(∼\)</span></td>
<td></td>
<td><span class="math inline">\(≡\)</span></td>
<td></td>
<td><span class="math inline">\(∝\)</span></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(≫\)</span></td>
<td></td>
<td><span class="math inline">\(≃\)</span></td>
<td></td>
<td><span class="math inline">\(⊥\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li><span class="math inline">\(a\ \cancel{R} \ a\)</span></li>
</ol>
<h2 id="杂七杂八">杂七杂八</h2>
<ol type="1">
<li>花体字母：<span class="math inline">\(\mathbb{R} \quad \mathcal{R}
\quad \mathscr{R}\)</span></li>
</ol>
]]></content>
      <categories>
        <category>编程语言/工具</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>关系和有向图 Relations and Digraphs</title>
    <url>/2022/11/10/%E5%85%B3%E7%B3%BB%E5%92%8C%E6%9C%89%E5%90%91%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="笛卡尔积-product-set-x2F-Cartesian-product"><a href="#笛卡尔积-product-set-x2F-Cartesian-product" class="headerlink" title="笛卡尔积 (product set&#x2F;Cartesian product)"></a><strong>笛卡尔积</strong> <em>(product set&#x2F;Cartesian product)</em></h2><ul>
<li>$A \times B &#x3D; \left\lbrace(a,b)|a\in A\  and \  b \in B\right\rbrace$</li>
</ul>
<h2 id="划分-partiton-x2F-quotient-set"><a href="#划分-partiton-x2F-quotient-set" class="headerlink" title="划分 (partiton&#x2F;quotient set)"></a><strong>划分</strong> <em>(partiton&#x2F;quotient set)</em></h2><span id="more"></span>

<h2 id="关系-relation"><a href="#关系-relation" class="headerlink" title="关系 (relation)"></a><strong>关系</strong> <em>(relation)</em></h2><ul>
<li>A <strong>relation</strong> $R$ from $A$ to $B$ is a subset of $A\times B$. </li>
<li>If $R\subseteq A\times B$ and $(a,b)\in R$, we say that $a$ <strong>is related to</strong> $b$ <strong>by</strong> $R$, and we also write $a\ R\ b$.</li>
<li>$R\subseteq A\times A$ <strong>is a relation on</strong> $A$.</li>
<li><strong>$R$-relative set of</strong> $x$: $R(x) &#x3D; \lbrace y\in B | x\ R\  y\rbrace$.</li>
<li><strong>$R$-relative set of</strong> $A_1\subseteq A$: $R(A_1) &#x3D; \lbrace y\in B | x\ R\  y$ for some $x$ in $A_1$$\rbrace$.<ul>
<li><em>Theorem 1:</em><ul>
<li>If $A_1\subseteq A_2$, then $R(A_1)\subseteq R(A_2)$.</li>
<li>$R(A_1\cup A_2)&#x3D; R(A_1)\cup R(A_2)$</li>
<li>$R(A_1\cap A_2)\subseteq R(A_1)\cap R(A_2)$</li>
</ul>
</li>
<li><em>Theorem 2:</em> Let $R$ and $S$ be relations from A to B. If $R(a)&#x3D;S(a)$ for all $a$ in $A$, then $R&#x3D; S$.</li>
</ul>
</li>
<li><strong>关系矩阵</strong> matrix of a relation: $A&#x3D;\lbrace a_1, a_2, …, a_m\rbrace$ and $B&#x3D;\lbrace a_1, a_2, …, a_m\rbrace$ are finite sets, and $R$ is a relation from $A$ to $B$, we represent $R$ by the $m\times n$ matrix $M_R&#x3D;[m_{ij}]$, which is defined by<br>  $$<br>  m_{ij}&#x3D;\left\lbrace<br>  \begin{aligned}<br>  1 &amp;  &amp; \text{if }(a_i, b_j)\in R, \\<br>  0 &amp;  &amp; \text{if }(a_i, b_j)\notin R.<br>  \end{aligned}<br>  \right.<br>  $$<br>  The matrix $M_R$ is called the <strong>matrix of</strong> $R$.</li>
</ul>
<h2 id="有向图-digraphs-x2F-directed-graph"><a href="#有向图-digraphs-x2F-directed-graph" class="headerlink" title="有向图 (digraphs&#x2F;directed graph)"></a><strong>有向图</strong> <em>(digraphs&#x2F;directed graph)</em></h2><ul>
<li>vertices, edge, in-degree, out-degree</li>
</ul>
<h2 id="路径-path"><a href="#路径-path" class="headerlink" title="路径 (path)"></a><strong>路径</strong> <em>(path)</em></h2><ul>
<li>A path of length n in $R$ from $a$ to $b$ is a finite sequence $\pi:a,x_1x_2,…x_{n-1},b$, beginning with $a$ and ending with $b$, such that $a\ R\ x_1,\ x_1\ R\ x_2,\ …,\ x_{n-1}\ R\ b$.</li>
<li>If $n$ is a fixed positive integer, $x\ R^n\ y$ means that there is a path of length $n$ from $x$ to $y$ in $R$.<ul>
<li>$R^\infty$ is sometimes called the <strong>connectivity relation</strong> for $R$.</li>
<li><em>Theorem 1:</em> If $R$ is a relation on $A&#x3D;\lbrace a_1,a_2,…,a_n\rbrace$, then $M_{R^2}&#x3D;M_R\odot M_R$.</li>
<li><em>Theorem 2:</em> For $n\geq 2$ and $R$ a relation on a finite set $A$, we have $$M_{R^n}&#x3D;M_R\odot M_R\odot … \odot M_R\quad (n\text{ factors}).$$</li>
</ul>
</li>
</ul>
<h1 id="关系的特性"><a href="#关系的特性" class="headerlink" title="关系的特性"></a>关系的特性</h1><h2 id="自反性-reflexive-and-irreflexive"><a href="#自反性-reflexive-and-irreflexive" class="headerlink" title="自反性 (reflexive and irreflexive)"></a>自反性 <em>(reflexive and irreflexive)</em></h2><ul>
<li>A relation $R$ on a set $A$ is <strong>reflexive</strong> if $(a,a)\in R$ for all $a\in A$, that is, if $a\ R\ a$ for all $a \in A$.<ul>
<li>关系矩阵对角线上所有元素值都为1。</li>
</ul>
</li>
<li>A relation $R$ on a set $A$ is <strong>irreflexive</strong> if $a\ \cancel{R} \ a$ for all $a \in A$.<ul>
<li>关系矩阵对角线上所有元素值都为0。</li>
</ul>
</li>
</ul>
<h2 id="对称性-symmetric-asymmetric-and-antisymmetric"><a href="#对称性-symmetric-asymmetric-and-antisymmetric" class="headerlink" title="对称性 (symmetric, asymmetric and antisymmetric)"></a>对称性 <em>(symmetric, asymmetric and antisymmetric)</em></h2><ul>
<li>对称 A relation $R$ on a set $A$ is <strong>symmetric</strong> if whenever $a\ R \ b$, then $b\ R\ a$.<ul>
<li>关系矩阵是对称矩阵。</li>
</ul>
</li>
<li>非对称 A relation $R$ on a set $A$ is <strong>asymmetric</strong> if whenever $a\ R \ b$, then $b\ \cancel{R}\ a$.<ul>
<li>关系矩阵对角线全为0；关于对角线对称的元素值不能全为1。</li>
</ul>
</li>
<li>反对称 A relation $R$ on a set $A$ is <strong>antisymmetric</strong> if whenever $a\ R \ b$ and $b\ R \ a$, then $a&#x3D;b$. <ul>
<li>关系矩阵对角线不限制；除对角线外，关于对角线对称的元素值不能全为1。</li>
</ul>
</li>
</ul>
<h2 id="传递性-transitive"><a href="#传递性-transitive" class="headerlink" title="传递性 (transitive)"></a>传递性 <em>(transitive)</em></h2><ul>
<li>A relation $R$ on a set $A$ is <strong>transitive</strong> if whenever $a\ R \ b$ and $b\ R \ c$, then $a\ R\ c$.<ul>
<li><em>Theorem 1:</em> A relation $R$ is transitive iff $R^n\subseteq R$ for all $n\geq 1$.</li>
<li><em>Theorem 2:</em> in terms of $R$-relative sets<ul>
<li>Reflexivity of $R$ means that $a\in R(a)$ for all $a$ in $A$.</li>
<li>Symmetry of $R$ means that $a\in R(b)$ iff $b\in R(a)$.</li>
<li>Transitivity of $R$ means that if $b\in R(a)$ and $c\in R(b)$, then $c\in R(a)$.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="等价关系-equivalence-relation"><a href="#等价关系-equivalence-relation" class="headerlink" title="等价关系 (equivalence relation)"></a>等价关系 <em>(equivalence relation)</em></h2><ul>
<li>A relation $R$ on a set $A$ is called an <strong>equivalence relation</strong> if it is reflexive, symmetric, and transitive.<ul>
<li><em>Theorem 1:</em> Let $\mathcal{P}$ be a partition of a set $A$ (Sets in $\mathcal{P}$ are called the blocks of $\mathcal{P}$). Define the relation $R$ on $A$ as follows:<br>$$<br>a\ R\ b\qquad \text{iff $a$ and $b$ are members of the same block.}<br>$$<br>Then $R$ is an equivalence relation on $A$.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CS 相关数理基础</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 动态内存分配</title>
    <url>/2022/11/12/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C 内存管理"></a>C 内存管理</h1><p>在程序的执行期间经常需要动态分配内存。</p>
<p>具体表现有在<em>函数体内声明</em>了一个变量、结构体或数组等，这样的内存是分配是由系统操作分配在<strong>栈</strong>上的，在执行完函数后，函数体内开头所声明的变量、结构体或数组所持有的内存空间都会被释放。所以要将函数体内的执行结果返回或反映到函数体外，一般是行不通的（不考虑全局变量）。</p>
<p>还有一种是由coder们调用 <code>malloc()</code> 等内存分配函数在<strong>堆</strong>上开辟新内存块，这些内存块会一起存在直至调用 <code>free()</code> 函数去释放。作用域广了，但也引入了潜在的内存泄露（程序卡顿）和野指针（程序 crash）问题。</p>
<ul>
<li>很多时候，我们无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。这时便需要动态分配内存。（但现在 C&#x2F;C++ 已经支持用变量定义数组长度了）</li>
</ul>
<h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">int</span> size)</span>; 和 <span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>malloc</code>: 在内存的动态存储区（堆区）分配 1 块长度为 size 的内存空间。返回该区域首地址。</li>
<li><code>calloc</code>: 在内存的动态存储区（堆区）分配 num 块长度为 size 的内存空间，并将每一个字节都<em>初始化</em>为 0。返回该区域首地址。</li>
</ul>
<p>这些函数可以在 <code>&lt;stdlib.h&gt;</code> 头文件中找到。<br>它们返回的是 void * 类型，也就是说，如果我们要为 int 或者其他类型的数据分配空间，必须显式强制转换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * ip_a;</span><br><span class="line">ip_a = (<span class="type">int</span> *)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (<span class="type">int</span>) * <span class="number">5</span> );</span><br><span class="line">或</span><br><span class="line">ip_a = (<span class="type">int</span> *)<span class="built_in">calloc</span>( <span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) );</span><br></pre></td></tr></table></figure>

<h2 id="重新调整内存的大小、释放内存"><a href="#重新调整内存的大小、释放内存" class="headerlink" title="重新调整内存的大小、释放内存"></a>重新调整内存的大小、释放内存</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *address, <span class="type">int</span> newsize)</span>; 和 	<span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>在不需要该内存时，都应调用函数 <code>free()</code> 来释放。</p>
<h2 id="示例：动态数组的定义和使用"><a href="#示例：动态数组的定义和使用" class="headerlink" title="示例：动态数组的定义和使用"></a>示例：动态数组的定义和使用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义动态数组指针，动态分配数组空间</span></span><br><span class="line">    <span class="type">int</span> *A, *T;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    A = (<span class="type">int</span> *)<span class="built_in">malloc</span>( n * <span class="keyword">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;存储分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用指针直接存</span></span><br><span class="line">    T = A;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n<span class="number">-2</span>; i++) &#123;</span><br><span class="line">        *T = i + <span class="number">1</span>;</span><br><span class="line">        T++;</span><br><span class="line">    &#125;</span><br><span class="line">    *T = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用指针直接取</span></span><br><span class="line">    T = A;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *T);</span><br><span class="line">        T++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态释放数组空间</span></span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-内存管理-1"><a href="#C-内存管理-1" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h1><h2 id="new-和-delete-运算符"><a href="#new-和-delete-运算符" class="headerlink" title="new 和 delete 运算符"></a><code>new</code> 和 <code>delete</code> 运算符</h2><p>在 C++ 中，使用 <code>new</code> 运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。 如果未成功，<code>new</code> 将返回 0 或引发异常。</p>
<p><code>delete</code> 运算符删除之前由 <code>new</code> 运算符分配的内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="type">double</span>;   <span class="comment">// 为变量请求内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理异常</span></span><br><span class="line"><span class="type">double</span>* pvalue  = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>( !(pvalue  = <span class="keyword">new</span> <span class="type">double</span> ))</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Error: out of memory.&quot;</span> &lt;&lt;endl;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pvalue;          <span class="comment">// 释放 pvalue 所指向的内存</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的动态内存分配"><a href="#数组的动态内存分配" class="headerlink" title="数组的动态内存分配"></a>数组的动态内存分配</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* pvalue  = <span class="literal">NULL</span>;   <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>]; <span class="comment">// 为变量请求内存</span></span><br><span class="line"><span class="keyword">delete</span> [] pvalue;       <span class="comment">// 删除 pvalue 所指向的数组</span></span><br></pre></td></tr></table></figure>

<h2 id="示例：分配和释放字符数组"><a href="#示例：分配和释放字符数组" class="headerlink" title="示例：分配和释放字符数组"></a>示例：分配和释放字符数组</h2><p>下面的代码示例分配类 <code>CName</code> 的一个字符数组和一个对象，然后释放它们。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">enum</span> &#123;</span><br><span class="line">      sizeOfBuffer = <span class="number">256</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> m_szFirst[sizeOfBuffer];</span><br><span class="line">   <span class="type">char</span> m_szLast[sizeOfBuffer];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(<span class="type">char</span>* pszFirst, <span class="type">char</span>* pszLast)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">strcpy_s</span>(m_szFirst, sizeOfBuffer, pszFirst);</span><br><span class="line">     <span class="built_in">strcpy_s</span>(m_szLast, sizeOfBuffer, pszLast);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Allocate memory for the array</span></span><br><span class="line">   <span class="type">char</span>* pCharArray = <span class="keyword">new</span> <span class="type">char</span>[CName::sizeOfBuffer];</span><br><span class="line">   <span class="built_in">strcpy_s</span>(pCharArray, CName::sizeOfBuffer, <span class="string">&quot;Array of characters&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Deallocate memory for the array</span></span><br><span class="line">   <span class="keyword">delete</span> [] pCharArray;</span><br><span class="line">   pCharArray = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allocate memory for the object</span></span><br><span class="line">   CName* pName = <span class="keyword">new</span> CName;</span><br><span class="line">   pName-&gt;<span class="built_in">SetName</span>(<span class="string">&quot;Firstname&quot;</span>, <span class="string">&quot;Lastname&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Deallocate memory for the object</span></span><br><span class="line">   <span class="keyword">delete</span> pName;</span><br><span class="line">   pName = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例：对使用-new-分配的对象进行初始化"><a href="#示例：对使用-new-分配的对象进行初始化" class="headerlink" title="示例：对使用 new 分配的对象进行初始化"></a>示例：对使用 <code>new</code> 分配的对象进行初始化</h2><p>以下示例说明了如何将初始化表达式与 <code>new</code> 运算符配合使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Acct</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Define default constructor and a constructor that accepts</span></span><br><span class="line">    <span class="comment">//  an initial balance.</span></span><br><span class="line">    <span class="built_in">Acct</span>() &#123;</span><br><span class="line">        balance = <span class="number">0.0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Acct</span>( <span class="type">double</span> init_balance ) &#123; </span><br><span class="line">        balance = init_balance; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Acct *CheckingAcct = <span class="keyword">new</span> Acct;</span><br><span class="line">    Acct *SavingsAcct = <span class="keyword">new</span> <span class="built_in">Acct</span> ( <span class="number">34.98</span> );</span><br><span class="line">    <span class="type">double</span> *HowMuch = <span class="keyword">new</span> <span class="type">double</span> &#123; <span class="number">43.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言/工具</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：图的最短路径算法</title>
    <url>/2022/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="用到的图的类定义（邻接矩阵存储）"><a href="#用到的图的类定义（邻接矩阵存储）" class="headerlink" title="用到的图的类定义（邻接矩阵存储）"></a>用到的图的类定义（邻接矩阵存储）</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MGraph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numVertices, numEdges;</span><br><span class="line">    <span class="type">char</span> VerticesList[maxVertices];</span><br><span class="line">    <span class="type">int</span> Edge[maxVertices][maxVertices];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getVertexPos</span><span class="params">(MGraph&amp; G, <span class="type">int</span> v)</span></span>;         <span class="comment">// 从顶点数据值找出顶点号</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(MGraph&amp; G, <span class="type">int</span> v)</span></span>;        <span class="comment">// 给出顶点 v 的第一个邻接顶点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextNeightbor</span><span class="params">(MGraph&amp; G, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>;  <span class="comment">// 给出顶点 v 某邻接顶点 w 的下一个邻接顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfVertices</span><span class="params">(MGraph&amp; G)</span></span>; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfEdges</span><span class="params">(MGraph&amp; G)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">getValue</span><span class="params">(MGraph&amp; G, <span class="type">int</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">(MGraph&amp; G, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="无权最短路径"><a href="#无权最短路径" class="headerlink" title="无权最短路径"></a>无权最短路径</h1>

<p>图的广度优先搜索</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unweighted</span><span class="params">(MGraph&amp; G, <span class="type">int</span> v, <span class="type">int</span> dist[], <span class="type">int</span> path[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> Q[queSieze]; <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;       <span class="comment">// 设置队列并置空</span></span><br><span class="line">    <span class="type">int</span> i, w, n = <span class="built_in">numberOfVertices</span>(G);</span><br><span class="line">    <span class="comment">// 距离数组初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dist[i] = maxVertices;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[v] = <span class="number">0</span>; path[v] = <span class="number">-1</span>;</span><br><span class="line">    Q[rear] = v; rear = (rear + <span class="number">1</span>) % queSize;       <span class="comment">// 源点进队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当队列不空时，逐层处理</span></span><br><span class="line">    <span class="keyword">while</span> (rear != front) &#123;</span><br><span class="line">        v = Q[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % queSize;              <span class="comment">// v 已处理，出队</span></span><br><span class="line">        <span class="comment">// 对 v 的各个邻接顶点 w 进行处理</span></span><br><span class="line">        <span class="keyword">for</span> (w = <span class="built_in">firstNeighbor</span>(G, v); w != <span class="number">-1</span>; w = <span class="built_in">nextNeighbor</span>(G, v, w)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[w] == maxVertices) &#123;</span><br><span class="line">            <span class="comment">// 若 w 未求得最短路径</span></span><br><span class="line">                dist[w] = dist[v] + <span class="number">1</span>;</span><br><span class="line">                path[w] = v;</span><br><span class="line">                Q[rear] = w;</span><br><span class="line">                rear = (rear + <span class="number">1</span>) % queSize;        <span class="comment">// w 进队尾</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>相关：树的层序遍历</li>
</ul>
<h1 id="非负权值的单源最短路径：Dijkstra-算法"><a href="#非负权值的单源最短路径：Dijkstra-算法" class="headerlink" title="非负权值的单源最短路径：Dijkstra 算法"></a>非负权值的单源最短路径：Dijkstra 算法</h1><p>Dijkstra 算法按路径长度的<strong>递增次序</strong>，逐步产生最短路径。本质上是贪心策略。在权值非负（所选最短路径长度<em>递增</em>）的情况下，Dijkstra算法所找的局部最优确实是全局最优。</p>
<ul>
<li>下一条最短路径总是通过“<strong>已产生的最短路径再扩充某一条边</strong>”得到。<ul>
<li>如果觉得不对劲，再次注意，产生的最短路径的长度是<em>递增</em>的。</li>
</ul>
</li>
</ul>
<ol>
<li>初始化：源点到源点的最短路径显然已找到，标记源点，以之为出发点，进行后续操作。</li>
<li>每次从未标记的顶点中，选择到达源点路径长度最短的顶点，进行标记，即该顶点已找到最短路径。</li>
<li>经由刚找到的最短路径，计算其后续邻接顶点（不包含已被标记的顶点）的路径长度，如果该长度比已知到该邻接顶点的长度更短，更新记录该长度和路径。</li>
<li>重复 2~3 直到所有顶点都被标记。</li>
</ol>
<h2 id="代码实现：Dijkstra-算法"><a href="#代码实现：Dijkstra-算法" class="headerlink" title="代码实现：Dijkstra 算法"></a>代码实现：Dijkstra 算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath</span><span class="params">(MGraph&amp; G, <span class="type">int</span> v, <span class="type">int</span> dist[], <span class="type">int</span> path[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 求顶点 v 到图 G 各顶点的最短路径，算法返回 dist[] 和 path[]</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">numberOfVertices</span>(G);</span><br><span class="line">    inst S[maxVertices];            <span class="comment">// 最短路径标记顶点集</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    weight w, min;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dist[i] = G.Edge[v][i];     <span class="comment">// 路径长度初始化</span></span><br><span class="line">        S[i] = <span class="number">0</span>;                   <span class="comment">// 标记初始化</span></span><br><span class="line">        <span class="keyword">if</span> (i != v &amp;&amp; dist[i] &lt; maxWeight) &#123;</span><br><span class="line">            path[i] = v;            <span class="comment">// 路径数组初始化（v 的邻接顶点）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> path[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[v] = <span class="number">1</span>; dist[v] = <span class="number">0</span>;          <span class="comment">// 到顶点 v 已找到最短路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个求 v 到其他顶点最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        min = maxWeight; </span><br><span class="line">        <span class="type">int</span> u = v;                  <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 找不在S中具有最短路径的顶点 u</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!S[j] &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                min = dist[j];</span><br><span class="line">            &#125;                       </span><br><span class="line">        &#125;                           </span><br><span class="line">        S[u] = <span class="number">1</span>;                   <span class="comment">// 将 u 加入集合 S</span></span><br><span class="line">        <span class="comment">// 修改经过 u 到其他顶点的路径长度</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            w = G.Edge[u][k];</span><br><span class="line">            <span class="keyword">if</span> (!S[k] &amp;&amp; w &lt; maxWeight &amp;&amp; dist[u] + w &lt; dist[k]) &#123;</span><br><span class="line">                <span class="comment">// 邻接顶点 k 未加入 S，且经过 u 到 k 比已知路径更短</span></span><br><span class="line">                dist[k] = dist[u] + w;</span><br><span class="line">                path[k] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码实现：从-path-数据读取最短路径"><a href="#代码实现：从-path-数据读取最短路径" class="headerlink" title="代码实现：从 path 数据读取最短路径"></a>代码实现：从 path 数据读取最短路径</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printShortestPath</span><span class="params">(MGraph&amp; G, <span class="type">int</span> v, Weight dist[], <span class="type">int</span> path[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从顶点[%c]到其他各顶点的最短路径为：\n&quot;</span>, G.VerticesList[v]);</span><br><span class="line">    <span class="type">int</span> i, j, k, n = <span class="built_in">numOfVertices</span>(G);</span><br><span class="line">    <span class="type">int</span> d[maxVertices];             <span class="comment">// 用于倒序存储最短路径上的顶点</span></span><br><span class="line">    <span class="comment">// 逐个顶点输出从 v0 到 v1的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// “倒序”存储该最短路径上的顶点到 d[] 并输出</span></span><br><span class="line">        <span class="keyword">if</span> (i != v) &#123;               </span><br><span class="line">            <span class="comment">// 存储部分</span></span><br><span class="line">            j = i; k = <span class="number">0</span>;           <span class="comment">// j 用于沿路径回溯直到源点</span></span><br><span class="line">            <span class="keyword">while</span> (j != v) &#123;</span><br><span class="line">                d[k++] = j;</span><br><span class="line">                j = path[j];        <span class="comment">// path[j] j 在最短路径上的“前一顶点”</span></span><br><span class="line">            &#125;</span><br><span class="line">            d[k++] = v;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 输出部分</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;到顶点[%c]的最短路径为：&quot;</span>, G.VerticesList[i]);</span><br><span class="line">            <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G.VerticesList[d[--k]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n最短路径长度为：%d\n&quot;</span>, dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="任意权值的单源最短路径：Bellman-Ford-算法"><a href="#任意权值的单源最短路径：Bellman-Ford-算法" class="headerlink" title="任意权值的单源最短路径：Bellman-Ford 算法"></a>任意权值的单源最短路径：Bellman-Ford 算法</h1><p>Dijkstra 算法属于贪心算法，求得局部最优解不一定能得到全局最优解。Bellman-Ford 算法<strong>从源点逐次绕过其他顶点</strong>，不断缩短到达终点的最短路径长度。它属于<strong>动态规划</strong>法。</p>
<ul>
<li>当图G<strong>没有带负权值边的回路</strong>时，有 $n$ 个顶点的图中任意两个顶点之间如果存在最短路径，此路径最多有 $n-1$条边。</li>
<li>为此，构造最短路径长度数组序列 dist$^1$[$u$]，dist$^2$[$u$]，…，dist$^{n-1}$[$u$]。<ul>
<li>dist$^{n-1}$[$u$] 是从源点 $v$ 出发最多经过不构成带负长度边回路的 $n-1$ 条边到达终点 $u$ 的最短路径的长度。算法的<strong>最终目的</strong>是计算出 dist$^{n-1}$[$u$]。</li>
</ul>
</li>
<li>可以用<strong>递推方式</strong>计算 dist$^{k}$[$u$]。<ul>
<li>设已经求出各顶点 $j$ 的 dist$^{k-1}$[$j$]，然后在邻接矩阵中取出 G.Edge[$j$][$u$]，<br>计算 min{ dist$^{k-1}$[$j$] + G.Edge[$j$][$u$] }，就可以得到从源点 $v$ <strong>绕过各个顶点</strong>，最多经过不构成带负长度边回路的 $k$ 条边到达终点 $u$ 的最短路径的长度。</li>
<li>用它与 dist$^{k-1}$[$u$] 比较，取小者作为 dist$^{k}$[$u$] 的值。</li>
<li>dist$^{1}$[$u$] &#x3D; G.Edge[$v$][$u$]<br>dist$^{k}$[$u$] &#x3D; min{ dist$^{k-1}$[$u$], min{ dist$^{k-1}$[$j$] + G.Edge[$j$][$u$] } }</li>
</ul>
</li>
</ul>
<h2 id="代码实现：-Bellman-Ford-算法"><a href="#代码实现：-Bellman-Ford-算法" class="headerlink" title="代码实现： Bellman-Ford 算法"></a>代码实现： Bellman-Ford 算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bellman_Ford</span><span class="params">(MGraph&amp; G, Weight dist[], <span class="type">int</span> path[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, k, u, n = G.numVertices;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dist[i] = G.Edge[<span class="number">0</span>][i];</span><br><span class="line">        path[i] = (G.Edge[<span class="number">0</span>][i] &lt; maxWeight) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递推求各顶点 dist[u]</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">2</span>; k &lt; n; k++) &#123;</span><br><span class="line">    <span class="comment">// 第 k 次循环后，能从源点经过 k 条边到达的 dist[u] 就不是无穷了</span></span><br><span class="line">        <span class="comment">// 终点 u </span></span><br><span class="line">        <span class="keyword">for</span> (u = <span class="number">1</span>; u &lt; n; u++) &#123;</span><br><span class="line">            <span class="comment">// k-1 之后多绕（经过）的顶点 i </span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">// 绕过后，是否缩短了路径？</span></span><br><span class="line">                <span class="keyword">if</span> (dist[u] &gt; dist[i] + G.Edge[i][u])</span><br><span class="line">                    &#123;dist[u] = dist[i] + G.Edge[i][u]; path[u] = i;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>$v_0,\ v_2,\ v_5,\ v_3,\ v_1$ 这样的路径是可以存在的吗？当然角标肯定不能重复，肯定不包括回路。书上的例子角标是递增的，但角标一定递增吗？</li>
</ul>
<h1 id="所有顶点之间最短路径：Floyd-算法"><a href="#所有顶点之间最短路径：Floyd-算法" class="headerlink" title="所有顶点之间最短路径：Floyd 算法"></a>所有顶点之间最短路径：Floyd 算法</h1><p>对于正权值所有顶点之间最短路径问题，轮流以每一个顶点为源点，重复执行 Dijkstra 算法 $n$ 次是一种方法，总的执行时间是 $O(n^3)$。</p>
<p>另外是 Floyd 算法，它支持任意权值，但不能包括负值回路。它的时间复杂度也是 $O(n^3)$。仍然应用<strong>动态规划</strong>的思想，持续增加绕过的顶点数。</p>
<p>定义一个 $n\times n$ 方阵 $A^{(-1)},\ A^{(-1)},\ …,\ A^{(n-1)}$，其中：</p>
<ul>
<li>$A^{(-1)}[i][j] &#x3D; \text{Edge}[i][j]$，</li>
<li>$A^{(k)}[i][j] &#x3D; \min{A^{(k-1)}[i][j],\ A^{(k-1)}[i][k]+A^{(k-1)}[k][j]},\ \ k &#x3D; 0,\ 1,\ …,\ n-1$<ul>
<li>由上述公式可知，$A^{(0)}[i][j]$是从顶点 $v_i$ 到 $v_j$，中间顶点是 $v_0$ 的最短路径的长度，$A^{(k)}[i][j]$是从顶点 $v_i$ 到 $v_j$，<strong>中间顶点的序号不大于</strong> $k$ 的最短路径的长度。</li>
<li>$k$ 表示<strong>运算步骤</strong>。</li>
</ul>
</li>
</ul>
<h2 id="代码实现：Floyd-算法"><a href="#代码实现：Floyd-算法" class="headerlink" title="代码实现：Floyd 算法"></a>代码实现：Floyd 算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(MGraph&amp; G, <span class="type">int</span> a[][maxVertices], <span class="type">int</span> path[][maxVertices])</span> </span>&#123;</span><br><span class="line"><span class="comment">// a[i][j] 是顶点 i 和 j 之间的最短路径长度，path[i][j] 是相应路径上顶点 j 的前一顶点的顶点号</span></span><br><span class="line"><span class="comment">// 算法计算每一对顶点间最短路径及最短路径长度</span></span><br><span class="line">    <span class="type">int</span> i, j, k, n = G.numVertices;</span><br><span class="line">    <span class="comment">// 矩阵 a 和 path 的初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i][j] = G.Edge[i][j];</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            path[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i][j] &lt; maxWeight) &#123;</span><br><span class="line">            path[i][j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> path[i][j] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逐步加入 vk 作为中间顶点</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="comment">// 对每条路径（矩阵上每一元素）进行松弛</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][k] + a[k][j] &lt; a[i][j]) &#123;</span><br><span class="line">                    a[i][j] = a[i][k] + a[k][j];</span><br><span class="line">                    path[i][j] = path[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="代码实现：从矩阵-path-读取最短路径"><a href="#代码实现：从矩阵-path-读取最短路径" class="headerlink" title="代码实现：从矩阵 path 读取最短路径"></a>代码实现：从矩阵 path 读取最短路径</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(MGraph&amp; G, <span class="type">int</span> u, <span class="type">int</span> v, Weight a[][maxVertices], <span class="type">int</span> path[][maxVertices])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 输入源点 u 和终点 v，输出最短路径和最短路径长度</span></span><br><span class="line">    <span class="type">char</span> x = G.VerticesList[u], y = G.VerticesList[v];</span><br><span class="line">    <span class="keyword">if</span> (path[u][v] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从 %c 到 %c 的最短路径为&quot;</span>, x, y);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d[maxVertices], pre, k;</span><br><span class="line">    k = <span class="number">0</span>; </span><br><span class="line">    d[k++] = v;</span><br><span class="line">    pre = path[u][v];</span><br><span class="line">    <span class="keyword">while</span> (pre != u) &#123;</span><br><span class="line">        d[k++] = pre;</span><br><span class="line">        pre = path[u][pre];</span><br><span class="line">    &#125;</span><br><span class="line">    d[k++] = u;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G.VerticesList[d[--k]]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;, 最短路径长度 = %d\n&quot;</span>, a[u][v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CS 专业基础课</category>
      </categories>
      <tags>
        <tag>图论算法</tag>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 图和网络算法（一）基本函数</title>
    <url>/2022/11/11/%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>主要参考MATLAB官方帮助文档：<br><a href="https://ww2.mathworks.cn/help/matlab/graph-and-network-algorithms_zh_CN.html">https://ww2.mathworks.cn/help/matlab/graph-and-network-algorithms_zh_CN.html</a></p>
<h1 id="创建、查询、修改图"><a href="#创建、查询、修改图" class="headerlink" title="创建、查询、修改图"></a>创建、查询、修改图</h1><p>图的绘图非自带函数，需要 <code>plot(g)</code> ，并在括号中设置 <code>&#39;options&#39;</code> 即可。其中，是否显示每条边的权值，由 <code>&#39;EdgeLabelMode&#39;</code> 设置。</p>
<h2 id="创建图"><a href="#创建图" class="headerlink" title="创建图"></a>创建图</h2><h3 id="邻接矩阵（关系矩阵）绘图"><a href="#邻接矩阵（关系矩阵）绘图" class="headerlink" title="邻接矩阵（关系矩阵）绘图"></a>邻接矩阵（关系矩阵）绘图</h3><p>使用邻接矩阵通过 <code>graph</code> 或 <code>digraph</code> 函数来创建图。反之，可以使用 <code>adjacency</code> 函数求预先存在的图的加权或未加权的稀疏邻接矩阵。</p>
<ol>
<li><p>创建无向图：必须是对称矩阵。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">g1 = [<span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;</span><br><span class="line">      <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">      <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">      <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">G = graph(g1); </span><br></pre></td></tr></table></figure>
<img src="/2022/11/11/%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/image1.png" class="" title="无向图">
</li>
<li><p>创建有向图：可以不是对称矩阵。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">MR = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">      <span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">      <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span>;</span><br><span class="line">      <span class="number">8</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">dG = digraph(MR); </span><br></pre></td></tr></table></figure>
<img src="/2022/11/11/%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/image2.png" class="" title="有向带权图"></li>
</ol>
<h3 id="边列表绘图"><a href="#边列表绘图" class="headerlink" title="边列表绘图"></a>边列表绘图</h3><p>对于稀疏矩阵和多重图（邻接矩阵无法表示多重图），列出所有边的边列表是更好的选择。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">source_nodes = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line">target_nodes = &#123;<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line">edge_weights = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>];</span><br><span class="line">G1 = graph(source_nodes, target_nodes, edge_weights);</span><br><span class="line">G2 = digraph(source_nodes, target_nodes, edge_weights);</span><br></pre></td></tr></table></figure>

<h2 id="图节点ID和高亮"><a href="#图节点ID和高亮" class="headerlink" title="图节点ID和高亮"></a>图节点ID和高亮</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>; <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>; <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">G = graph(A, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;);</span><br><span class="line">p = shortestpath(G, <span class="number">1</span>, <span class="number">4</span>)                     <span class="comment">% p = 1 3 4</span></span><br><span class="line">p1 = shortestpath(G, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)                <span class="comment">% p = &#123;&#x27;a&#x27;&#125; &#123;&#x27;c&#x27;&#125; &#123;&#x27;d&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>用数据结构课上 Dijkstra 算法例子里的图小小试一下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">source_nodes = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span>] + <span class="number">1</span>;</span><br><span class="line">target_nodes = [<span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">4</span>] + <span class="number">1</span>;</span><br><span class="line">edge_weights = [<span class="number">10</span> <span class="number">30</span> <span class="number">100</span> <span class="number">50</span> <span class="number">10</span> <span class="number">20</span> <span class="number">60</span>];</span><br><span class="line">G = digraph(source_nodes, target_nodes, edge_weights);</span><br><span class="line">H = plotDigraph(G);</span><br><span class="line">p = shortestpath(G, <span class="number">1</span>, <span class="number">5</span>)                     <span class="comment">% p = 1 4 3 5</span></span><br><span class="line"><span class="comment">% 突出显示最短路径</span></span><br><span class="line">highlight(H, p, <span class="string">&#x27;EdgeColor&#x27;</span>,[<span class="number">255</span> <span class="number">127</span> <span class="number">80</span>]/<span class="number">255</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>) </span><br></pre></td></tr></table></figure>
<img src="/2022/11/11/%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/image5.png" class="" title="最短路径高亮">]]></content>
      <categories>
        <category>编程语言/工具</category>
      </categories>
      <tags>
        <tag>图论算法</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：活动网络</title>
    <url>/2022/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%B4%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CS 专业基础课</category>
      </categories>
      <tags>
        <tag>图论算法</tag>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：图的遍历和最小生成树算法</title>
    <url>/2022/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="用到的图的类定义"><a href="#用到的图的类定义" class="headerlink" title="用到的图的类定义"></a>用到的图的类定义</h1><p>终于用 C++ 面向对象的方式写出来了。只列了必要的函数，还有既然写过了不妨放上去的函数（比如 <code>MGraph</code> 的构造函数）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _numVertices;           <span class="comment">// 实际顶点数</span></span><br><span class="line">    <span class="type">int</span> _numEdges;              <span class="comment">// 实际边数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfVertices</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _numVertices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfEdges</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _numEdges;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getVertexPos</span><span class="params">(T v)</span> <span class="type">const</span> </span>= <span class="number">0</span>;      <span class="comment">// 由数据值 v 找顶点号</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">getValue</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span> </span>= <span class="number">0</span>;          <span class="comment">// 取顶点 v 的值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> W <span class="title">getWeight</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 取边 (v, w) 上的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span> </span>= <span class="number">0</span>;           <span class="comment">// 返回顶点 v 的第一个邻接顶点的顶点号或 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> <span class="type">const</span> </span>= <span class="number">0</span>;     <span class="comment">// 返回顶点 v 的排在某邻接顶点 w 后面的下一个邻接顶点或 -1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNumOfVertices</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        _numVertices = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNumOfEdges</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        _numEdges = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵表示的图</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MGraph</span> : <span class="keyword">public</span> Graph&lt;T, W&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;T&gt; VerticesList;                 <span class="comment">// 顶点表</span></span><br><span class="line">    W Edge[maxVertices][maxVertices];  <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MGraph</span>(vector&lt;T&gt; v, T ed[][<span class="number">2</span>], vector&lt;W&gt; c, <span class="type">int</span> n, <span class="type">int</span> e, <span class="type">int</span> d);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getVertexPos</span><span class="params">(T v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="number">-1</span>) <span class="keyword">return</span> VerticesList[v];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> impossibleValue;</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="function">W <span class="title">getWeight</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( v != <span class="number">-1</span> &amp;&amp; w != <span class="number">-1</span> ) <span class="keyword">return</span> Edge[v][w];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> impossibleWeight;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span></span>;           </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> <span class="type">const</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMGraph</span><span class="params">(<span class="type">int</span> d)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表表示的图</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALGraph</span> : <span class="keyword">public</span> Graph&lt;T, W&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边结点的定义</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EdgeNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> dest;       <span class="comment">// 边的另一顶点的顶点号</span></span><br><span class="line">        W cost;         <span class="comment">// 边上的权值</span></span><br><span class="line">        EdgeNode *link;    <span class="comment">// 下一条边链指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">VertexNode</span> &#123;</span><br><span class="line">        T data;</span><br><span class="line">        EdgeNode *adj;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;VertexNode&gt; VerticesList;                 <span class="comment">// 顶点表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getVertexPos</span><span class="params">(T v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="number">-1</span>) <span class="keyword">return</span> VerticesList[v].data;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> impossibleValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">W <span class="title">getWeight</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span></span>;           </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> <span class="type">const</span></span>; </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>通过遍历，可以找出某个顶点所在的极大连通子图，可以消除图中的所有回路，可以找出关节点等。</p>
<ul>
<li>图中可能存在回路，为避免再次访问，需要标志数组 <code>visited[]</code></li>
</ul>
<h2 id="深度优先搜索-Depth-First-Search-DFS"><a href="#深度优先搜索-Depth-First-Search-DFS" class="headerlink" title="深度优先搜索 Depth First Search, DFS"></a>深度优先搜索 Depth First Search, DFS</h2><p>深度优先搜索属于<strong>回溯法</strong>。从源点出发不断向前访问邻接顶点，直到前进到 $v_k$ 而其所有邻接顶点都已被访问（所有邻接顶点在 <code>visited[]</code> 数组中已标为 1），则向前<strong>回溯</strong>一个顶点，再度出发。</p>
<h3 id="代码实现：深度优先搜索"><a href="#代码实现：深度优先搜索" class="headerlink" title="代码实现：深度优先搜索"></a>代码实现：深度优先搜索</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_recur</span><span class="params">(MGraph&amp; G, <span class="type">int</span> v, <span class="type">int</span> visited[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 从顶点 v 出发，以深度优先的次序访问所有尚未访问过的顶点</span></span><br><span class="line">    <span class="comment">// 访问出发点 v ，作标记</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; G.<span class="built_in">getValue</span>(v) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = G.<span class="built_in">firstNeighbor</span>(v); w != <span class="number">-1</span>; w = G.<span class="built_in">nextNeighbor</span>(v, w)) &#123;</span><br><span class="line">        <span class="comment">// 若 v 的邻接顶点 w 未访问过，递归访问 w</span></span><br><span class="line">        <span class="comment">// 所有 w 都被访问了，则该层递归结束，回到上一层</span></span><br><span class="line">        <span class="keyword">if</span> (! visited[w]) &#123;</span><br><span class="line">            <span class="built_in">DFS_recur</span>(G, w, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_Traversal</span><span class="params">(MGraph&amp; G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="type">int</span> i, n = G.<span class="built_in">numberOfVertices</span>();</span><br><span class="line">    <span class="type">int</span> visited[maxVertices];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DFS_recur</span>(G, v, visited);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CS 专业基础课</category>
      </categories>
      <tags>
        <tag>图论算法</tag>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 面向对象概览</title>
    <url>/2022/11/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>主要参考：<br><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/cpp/?view=msvc-170</a><br><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">https://www.runoob.com/cplusplus/cpp-tutorial.html</a></p>
<h1 id="示例一-dog"><a href="#示例一-dog" class="headerlink" title="示例一 dog"></a>示例一 <code>dog</code></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dog</span>() &#123;</span><br><span class="line">        _legs = <span class="number">4</span>;</span><br><span class="line">        _bark = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDogSize</span><span class="params">(string dogSize)</span> </span>&#123;</span><br><span class="line">        _dogSize = dogSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setEars</span><span class="params">(string type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// virtual function</span></span><br><span class="line">        _earType = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _dogSize, _earType;</span><br><span class="line">    <span class="type">int</span> _legs;</span><br><span class="line">    <span class="type">bool</span> _bark;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="风格：下划线变量"><a href="#风格：下划线变量" class="headerlink" title="风格：下划线变量"></a>风格：下划线变量</h2><p>注意到 <code>_dogSize</code>、<code>_earType</code> 等变量名称前面都加了下划线。这没有实质影响，只是风格问题。将成员变量或者私有成员变量的前面加上下划线，以表示该变量是某个类的<strong>属性</strong>。</p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _size;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h2><p>更深入地，这一话题涉及到<strong>继承</strong>的问题，本文暂不具体涉猎。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">breed</span> : <span class="keyword">public</span> dog &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">breed</span>( string color, string size) &#123;</span><br><span class="line">        _color = color;</span><br><span class="line">        <span class="built_in">setDogSize</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// virtual function redefined</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setEars</span><span class="params">(string length, string type)</span> </span>&#123;</span><br><span class="line">        _earLength = length;</span><br><span class="line">        _earType = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   string _color, _earLength, _earType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例-Document"><a href="#示例-Document" class="headerlink" title="示例 Document"></a>示例 <code>Document</code></h3><p>当在派生类中重新定义了直接或间接基类的成员时，范围解析运算符 (<code>::</code>) 可用于引用这些成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> *Name;   <span class="comment">// Document name.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintNameOf</span><span class="params">()</span></span>;   <span class="comment">// Print name.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation of PrintNameOf function from class Document.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Document::PrintNameOf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> : <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Book</span>( <span class="type">char</span> *name, <span class="type">long</span> pagecount );</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">long</span>  PageCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor from class Book.</span></span><br><span class="line">Book::<span class="built_in">Book</span>( <span class="type">char</span> *name, <span class="type">long</span> pagecount ) &#123;</span><br><span class="line">    Name = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>( name ) + <span class="number">1</span> ];</span><br><span class="line">    <span class="built_in">strcpy_s</span>( Name, <span class="built_in">strlen</span>(Name), name );</span><br><span class="line">    PageCount = pagecount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="在-main-中进行实例化"><a href="#在-main-中进行实例化" class="headerlink" title="在 main 中进行实例化"></a>在 <code>main</code> 中进行实例化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   dog mongrel;</span><br><span class="line">   <span class="function">breed <span class="title">labrador</span><span class="params">(<span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;large&quot;</span>)</span></span>;</span><br><span class="line">   mongrel.<span class="built_in">setEars</span>(<span class="string">&quot;pointy&quot;</span>);</span><br><span class="line">   labrador.<span class="built_in">setEars</span>(<span class="string">&quot;long&quot;</span>, <span class="string">&quot;floppy&quot;</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Cody is a &quot;</span> &lt;&lt; labrador.<span class="built_in">getColor</span>() &lt;&lt; <span class="string">&quot; labrador&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="虚函数-virtual"><a href="#虚函数-virtual" class="headerlink" title="虚函数 virtual"></a>虚函数 <code>virtual</code></h2><p>虚函数是在<strong>基类中</strong>使用关键字 <code>virtual</code> 声明的函数，应在<strong>派生类中重新定义</strong>。它在派生类中被重新定义时，会告诉编译器不要静态链接到该函数。（Java中的 <code>override</code>）</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。</p>
<p>C++ 中的虚函数的作用主要是实现了<strong>多态</strong>的机制。</p>
<blockquote>
<p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到<strong>纯虚函数</strong>。这将涉及到<strong>抽象类</strong>。</p>
<blockquote>
<ul>
<li>C++ <strong>接口</strong>是使用<strong>抽象类</strong>来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。</li>
<li>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的。</li>
<li>设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类<strong>不能被用于实例化</strong>对象，它<strong>只能作为接口</strong>使用。如果试图实例化一个抽象类的对象，会导致编译错误。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="示例-Account"><a href="#示例-Account" class="headerlink" title="示例 Account"></a>示例 <code>Account</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Account</span>( <span class="type">double</span> d ) &#123; _balance = d; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Account</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetBalance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _balance; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrintBalance</span><span class="params">()</span> </span>&#123; cerr &lt;&lt; <span class="string">&quot;Error. Balance not available for base type.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> _balance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckingAccount</span> : <span class="keyword">public</span> Account &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">CheckingAccount</span>(<span class="type">double</span> d) : <span class="built_in">Account</span>(d) &#123;&#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">PrintBalance</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Checking account balance: &quot;</span> &lt;&lt; <span class="built_in">GetBalance</span>() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="示例二-Box"><a href="#示例二-Box" class="headerlink" title="示例二 Box"></a>示例二 <code>Box</code></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;default&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="comment">// 成员初始化表达式列表</span></span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> length)</span><br><span class="line">       : <span class="built_in">m_width</span>(width), <span class="built_in">m_height</span>(height), <span class="built_in">m_length</span>(length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;int,int,int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>(Box&amp; other)</span><br><span class="line">       : <span class="built_in">m_width</span>(other.m_width), <span class="built_in">m_height</span>(other.m_height), <span class="built_in">m_length</span>(other.m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>(Box&amp;&amp; other) : <span class="built_in">m_width</span>(other.m_width), <span class="built_in">m_height</span>(other.m_height), <span class="built_in">m_length</span>(other.m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_contents = std::<span class="built_in">move</span>(other.m_contents);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Volume</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_width * m_height * m_length; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add_Item</span><span class="params">(string item)</span> </span>&#123; m_contents.<span class="built_in">push_back</span>(item); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print_Contents</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m_contents)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_width&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> m_height&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> m_length&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    vector&lt;string&gt; m_contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>若要自定义类初始化其成员的方式，或是如要在创建类的对象时调用函数，需要定义构造函数。</p>
<ul>
<li>构造函数具有与类相同的名称，没有返回值。</li>
<li>可以定义<strong>所需数量的重载构造函数</strong>，以各种方式自定义初始化。</li>
<li>通常，构造函数具有公共可访问性，以便类定义或继承层次结构外部的代码可以创建类的对象。 但也可以将构造函数声明为 <code>protected</code> 或 <code>private</code>。</li>
<li>构造函数按此顺序执行工作：<ol>
<li>按<strong>声明顺序</strong>调用基类和成员构造函数。</li>
<li>如果类派生自虚拟基类，则会将对象的虚拟基指针初始化。</li>
<li>如果类具有或继承了虚函数，则会将对象的虚函数指针初始化。 虚函数指针指向类中的虚函数表，确保虚函数正确地调用绑定代码。</li>
<li>它执行自己函数体中的所有代码。</li>
</ol>
</li>
</ul>
<h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>默认构造函数通常没有参数，但它们可以具有带默认值的参数。如果声明了任何非默认构造函数，编译器不会提供默认构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>() &#123; <span class="comment">/*perform any required default initialization steps*/</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All params have default values</span></span><br><span class="line">    <span class="built_in">Box</span> (<span class="type">int</span> w = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> h = <span class="number">1</span>): <span class="built_in">m_width</span>(w), <span class="built_in">m_height</span>(h), <span class="built_in">m_length</span>(l)&#123;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员初始化表达式列表"><a href="#成员初始化表达式列表" class="headerlink" title="成员初始化表达式列表"></a>成员初始化表达式列表</h3><p>构造函数可以选择具有成员初始化表达式列表，该列表会在构造函数主体运行之前初始化类成员。</p>
<h3 id="用构造函数进行实例化"><a href="#用构造函数进行实例化" class="headerlink" title="用构造函数进行实例化"></a>用构造函数进行实例化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Box <span class="title">get_Box</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">b</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>, <span class="number">18</span>)</span></span>; <span class="comment">// &quot;int,int,int&quot;</span></span><br><span class="line">    b.<span class="built_in">Add_Item</span>(<span class="string">&quot;Toupee&quot;</span>);</span><br><span class="line">    b.<span class="built_in">Add_Item</span>(<span class="string">&quot;Megaphone&quot;</span>);</span><br><span class="line">    b.<span class="built_in">Add_Item</span>(<span class="string">&quot;Suit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Box b; <span class="comment">// &quot;default&quot;</span></span><br><span class="line">    <span class="function">Box <span class="title">b1</span><span class="params">(b)</span></span>; <span class="comment">// &quot;copy&quot;</span></span><br><span class="line">    <span class="function">Box <span class="title">b2</span><span class="params">(get_Box())</span></span>; <span class="comment">// &quot;move&quot;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b2 contents: &quot;</span>;</span><br><span class="line">    b2.<span class="built_in">Print_Contents</span>(); <span class="comment">// Prove that we have all the values</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    cin &gt;&gt; ch; <span class="comment">// keep window open</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实例三-Stack"><a href="#实例三-Stack" class="headerlink" title="实例三 Stack"></a>实例三 <code>Stack</code></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123; </span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">    vector&lt;T&gt; elems;     <span class="comment">// 元素 </span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;  <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;               <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;       <span class="comment">// 如果为空则返回真。</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>


<h2 id="风格：const-的使用"><a href="#风格：const-的使用" class="headerlink" title="风格：const 的使用"></a>风格：<code>const</code> 的使用</h2><p>声明带 <code>const</code> 关键字的成员函数将指定该函数是一个“<strong>只读</strong>”函数，它不会修改为其调用该函数的对象。 常量成员函数不能修改任何非静态数据成员或调用不是常量的任何成员函数。 常量成员函数声明和定义中都需要 <code>const</code> 关键字。</p>
<h2 id="风格：引用类型函数自变量"><a href="#风格：引用类型函数自变量" class="headerlink" title="风格：引用类型函数自变量"></a>风格：引用类型函数自变量</h2><p>向函数<strong>传递引用</strong>而非大型对象的效率通常更高。 这使编译器能够在保持已用于访问对象的语法的同时传递对象的地址。</p>
<p>尽管作为引用类型传递的参数遵循了非指针类型的语法，但它们仍然保留了指针类型的一个重要特征：除非被声明为 const，否则它们是可以修改的。 如果目的<strong>不是修改对象</strong> <code>date</code>，相比<code>long DateOfYear( Date&amp; date )</code>更合适的函数原型是<code>long DateOfYear( const Date&amp; date );</code>。</p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>可以在类模板的内部或外部定义成员函数。 如果在类模板的<strong>外部定义成员函数</strong>，则会像<strong>定义函数模板</strong>一样定义它们。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 追加传入元素的副本</span></span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem);    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span> () </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    elems.<span class="built_in">pop_back</span>();         </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Stack&lt;T&gt;::<span class="built_in">top</span> () <span class="type">const</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最后一个元素的副本 </span></span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>();      </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="类模板实例化"><a href="#类模板实例化" class="headerlink" title="类模板实例化"></a>类模板实例化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        Stack&lt;<span class="type">int</span>&gt;         intStack;  <span class="comment">// int 类型的栈 </span></span><br><span class="line">        Stack&lt;string&gt; stringStack;    <span class="comment">// string 类型的栈 </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 int 类型的栈 </span></span><br><span class="line">        intStack.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line">        cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt;endl; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 string 类型的栈 </span></span><br><span class="line">        stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">        cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (exception <span class="type">const</span>&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt;endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言/工具</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>面向对象程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 面向对象的尝试：图的类定义</title>
    <url>/2022/11/15/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B0%9D%E8%AF%95%EF%BC%9A%E5%9B%BE%E7%9A%84%E7%B1%BB%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<ol>
<li>无论什么继承方式，派生类都不能访问基类的 <code>private</code> 成员，只能间接访问。</li>
<li>不知为什么，在派生类的成员函数定义中类中调用基类函数，不加 <code>this-&gt;</code> 就无法编译通过。</li>
<li>本来想用 <code>vector</code> 实现二维数组，但好像很麻烦。搁置了。</li>
<li>怎么输出可视化的图呢？有时间再搞吧。还没有研究过 C++ 的可视化。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> impossibleValue <span class="string">&#x27;#&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> impossibleWeight -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxVertices 30		<span class="comment">//图中顶点数最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxEdges 900		<span class="comment">//最大边数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxWeight 32767	<span class="comment">//最大权值</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _numVertices;           <span class="comment">// 实际顶点数</span></span><br><span class="line">    <span class="type">int</span> _numEdges;              <span class="comment">// 实际边数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfVertices</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _numVertices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfEdges</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _numEdges;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getVertexPos</span><span class="params">(T v)</span> <span class="type">const</span> </span>= <span class="number">0</span>;      <span class="comment">// 由数据值 v 找顶点号</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">getValue</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span> </span>= <span class="number">0</span>;          <span class="comment">// 取顶点 v 的值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> W <span class="title">getWeight</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 取边 (v, w) 上的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span> </span>= <span class="number">0</span>;           <span class="comment">// 返回顶点 v 的第一个邻接顶点的顶点号或 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> <span class="type">const</span> </span>= <span class="number">0</span>;     <span class="comment">// 返回顶点 v 的排在某邻接顶点 w 后面的下一个邻接顶点或 -1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNumOfVertices</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        _numVertices = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNumOfEdges</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        _numEdges = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵表示的图</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MGraph</span> : <span class="keyword">public</span> Graph&lt;T, W&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;T&gt; VerticesList;                 <span class="comment">// 顶点表</span></span><br><span class="line">    W Edge[maxVertices][maxVertices];  <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MGraph</span>(vector&lt;T&gt; v, T ed[][<span class="number">2</span>], vector&lt;W&gt; c, <span class="type">int</span> n, <span class="type">int</span> e, <span class="type">int</span> d);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getVertexPos</span><span class="params">(T v)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="number">-1</span>) <span class="keyword">return</span> VerticesList[v];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> impossibleValue;</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="function">W <span class="title">getWeight</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( v != <span class="number">-1</span> &amp;&amp; w != <span class="number">-1</span> ) <span class="keyword">return</span> Edge[v][w];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> impossibleWeight;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span></span>;           </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="comment">// 输出图的数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMGraph</span><span class="params">(<span class="type">int</span> d)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line">MGraph&lt;T, W&gt;::<span class="built_in">MGraph</span>(vector&lt;T&gt; v, T ed[][<span class="number">2</span>], vector&lt;W&gt; c, <span class="type">int</span> n, <span class="type">int</span> e, <span class="type">int</span> d) : <span class="built_in">VerticesList</span>(v) &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setNumOfEdges</span>(e);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setNumOfVertices</span>(n);</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            Edge[i][j] = (i == j) ? <span class="number">0</span> : maxWeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; e; k++) &#123;</span><br><span class="line">        i = <span class="built_in">getVertexPos</span>(ed[k][<span class="number">0</span>]);</span><br><span class="line">        j = <span class="built_in">getVertexPos</span>(ed[k][<span class="number">1</span>]);</span><br><span class="line">        Edge[i][j] = c[k];</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">            Edge[j][i] = c[k];  <span class="comment">// 无向图，对称元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言/工具</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>面向对象程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 面向对象：运算符重载</title>
    <url>/2022/11/15/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>你可以在全局或为各个类重新定义大多数内置运算符的函数。 重载运算符作为函数来实现。重载运算符的名称是 <code>operatorX</code>。 例如，若要重载加法运算符，需要定义一个名为“operator+”的函数。 同样地，若要重载加法&#x2F;赋值运算符 +&#x3D;，需要定义一个名为“operator+&#x3D;”的函数。</p>
<h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><p>尽管通常是在代码中遇到重载运算符时由编译器对其进行隐式调用，但也可以按照与调用任何成员或非成员函数相同的方式来显式调用重载运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point pt;</span><br><span class="line">pt.<span class="keyword">operator</span>+( <span class="number">3</span> );  <span class="comment">// Call addition operator to add 3 to pt.</span></span><br></pre></td></tr></table></figure>

<h1 id="示例-Complex"><a href="#示例-Complex" class="headerlink" title="示例 Complex"></a>示例 <code>Complex</code></h1><p>以下示例重载 + 运算符，将两个复数相加并返回结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">   <span class="built_in">Complex</span>( <span class="type">double</span> r, <span class="type">double</span> i ) : <span class="built_in">re</span>(r), <span class="built_in">im</span>(i) &#123;&#125;</span><br><span class="line">   Complex <span class="keyword">operator</span>+( Complex &amp;other );</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">( )</span> </span>&#123;   cout &lt;&lt; re &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; im &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">double</span> re, im;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Operator overloaded using a member function</span></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+( Complex &amp;other ) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Complex</span>( re + other.re, im + other.im );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Complex a = <span class="built_in">Complex</span>( <span class="number">1.2</span>, <span class="number">3.4</span> );</span><br><span class="line">   Complex b = <span class="built_in">Complex</span>( <span class="number">5.6</span>, <span class="number">7.8</span> );</span><br><span class="line">   Complex c = <span class="built_in">Complex</span>( <span class="number">0.0</span>, <span class="number">0.0</span> );</span><br><span class="line"></span><br><span class="line">   c = a + b;</span><br><span class="line">   c.<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言/工具</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>面向对象程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>IELTS 日常积累 1/7</title>
    <url>/2022/11/19/IELTS-%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF-1-7/</url>
    <content><![CDATA[<p>刚发现后天居然考雅思口语了。下周六考其他的。希望一次性取得好成绩，虽然几乎是裸考。记录一下这个超短冲刺。</p>
<h1 id="单词-x2F-短语积累"><a href="#单词-x2F-短语积累" class="headerlink" title="单词&#x2F;短语积累"></a>单词&#x2F;短语积累</h1><hr>
<ul>
<li><p style="text-align:left;">turn a blind eye to<span style="float:right;">另一部分文字</span></p></li>
<li>turn a deaf ear to</li>
</ul>
<hr>
<ul>
<li>on the brink &#x2F; margin &#x2F; verge &#x2F; edge of</li>
</ul>
<hr>
<ul>
<li>almost &#x2F; nearly &#x2F; most &#x2F; virtually &#x2F; practically</li>
</ul>
<hr>
<p>预示</p>
<ul>
<li>presage n. 预示；前兆；预感 v. 预示；预兆</li>
<li>forecast n. &#x2F; v. 预测；预报</li>
<li>foretell v. 预言；预示；预卜</li>
<li>portend v. 预兆；预示</li>
<li>prefigure v. 预示；预想</li>
<li>bode v. 预示；是…的兆头</li>
<li>auspice n. 预兆；前兆；吉兆</li>
<li>harbinger n. 预兆；先兆</li>
<li>propitious adj. 有利的；吉祥的；吉利的</li>
<li>portentous adj. 预示的；凶兆的；装腔作势的</li>
</ul>
<hr>
<ul>
<li>cormorant n. 鸬鹚；贪婪的人 adj. 贪心的</li>
<li>vulture n. 兀鹫；秃鹫；贪得无厌的人</li>
<li>avaricious adj. 贪财的；贪婪的</li>
<li>voracious  adj. 贪吃的；贪婪的；如饥似渴的</li>
<li>rapacious adj. 贪婪的；贪得无厌的；劫掠的</li>
<li>covetous adj. 贪心的；贪婪的；渴望的</li>
<li>acquisitive adj. 渴望获得的；贪得无厌的</li>
</ul>
<hr>
<ul>
<li>maladroit adj. 笨拙的；不机敏的；笨手笨脚的 n. 一个笨拙愚蠢的人</li>
<li>adroit adj. 熟练的；灵巧的<ul>
<li>dexterous adj. 灵巧的（手）；熟练的；敏捷的</li>
</ul>
</li>
<li>malign adj. 有害的；恶意的 v. 中伤；污蔑</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>IELTS</category>
      </categories>
      <tags>
        <tag>IELTS</tag>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 正则表达式实际应用</title>
    <url>/2022/11/19/%E7%94%A8Python-%E8%A7%A3%E5%86%B3%E4%B8%8B%E6%AD%A3%E9%81%87%E5%88%B0%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>这确实是我自己现在需要处理的事情……对于以下这段文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">预示</span><br><span class="line"></span><br><span class="line">- presage n. 预示；前兆；预感 v. 预示；预兆</span><br><span class="line">- forecast n. / v. 预测；预报</span><br><span class="line">- foretell v. 预言；预示；预卜</span><br><span class="line">- portend v. 预兆；预示</span><br><span class="line">- prefigure v. 预示；预想</span><br><span class="line">- bode v. 预示；是...的兆头</span><br><span class="line">- auspice n. 预兆；前兆；吉兆</span><br><span class="line">- harbinger n. 预兆；先兆</span><br><span class="line">- propitious adj. 有利的；吉祥的；吉利的</span><br><span class="line">- portentous adj. 预示的；凶兆的；装腔作势的</span><br><span class="line"></span><br><span class="line">***</span><br></pre></td></tr></table></figure>

<p>希望每行单词能够变成这样的形式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;text-align:left;&quot;</span>&gt;</span>presage<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;float:right;&quot;</span>&gt;</span>n. 预示；前兆；预感 v. 预示；预兆<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其余每行保持不变。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="按行读取文件"><a href="#按行读取文件" class="headerlink" title="按行读取文件"></a>按行读取文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file_path&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br></pre></td></tr></table></figure>


<h2 id="Python-正则表达式"><a href="#Python-正则表达式" class="headerlink" title="Python 正则表达式"></a>Python 正则表达式</h2><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</p>
<h3 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a><code>re.match</code>函数</h3><p>re.match 尝试从字符串的<strong>起始位置</strong>匹配一个模式。匹配成功 <code>re.match</code> 方法返回一个<strong>匹配的对象</strong>，否则返回 None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.<span class="keyword">match</span>(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">print</span>(re.<span class="keyword">match</span>(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())  <span class="comment"># 在起始位置匹配 (.span() 表示区间) </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(re.<span class="keyword">match</span>(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>))         <span class="comment"># 不在起始位置匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h4 id="匹配对象方法-group-num-和-groups"><a href="#匹配对象方法-group-num-和-groups" class="headerlink" title="匹配对象方法 group(num) 和 groups()"></a>匹配对象方法 <code>group(num)</code> 和 <code>groups()</code></h4><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search"></a><code>re.search</code></h3>]]></content>
      <categories>
        <category>编程语言/工具</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title>IELTS 口语一日冲刺记录</title>
    <url>/2022/11/20/IELTS-%E5%8F%A3%E8%AF%AD%E5%86%B2%E5%88%BA%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><h2 id="Part-1-Strategies-and-skills"><a href="#Part-1-Strategies-and-skills" class="headerlink" title="Part 1 - Strategies and skills"></a>Part 1 - Strategies and skills</h2><h3 id="Common-triggers-or-questions"><a href="#Common-triggers-or-questions" class="headerlink" title="Common triggers or questions"></a>Common triggers or questions</h3><p>The 6 most common triggers or questions in IELTS Speaking Part 1 are:</p>
<ul>
<li>Do you <em>VERB</em>?<ul>
<li>How long you have done it?<ul>
<li><blockquote>
<p>I’ve played since I was a child.</p>
</blockquote>
</li>
</ul>
</li>
<li>How often you do it?<ul>
<li><blockquote>
<p>regularly, once in a blue moon, every now and again, on a fairl y regular basis</p>
</blockquote>
</li>
<li><blockquote>
<p>on a daily &#x2F; weekly &#x2F;monthly basis</p>
</blockquote>
</li>
<li><blockquote>
<p>rarely &#x2F; hardly ever</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>Are you good at it?</li>
<li>Did you <em>VERB</em> as a child?</li>
<li>Do you prefer <em>A</em> or <em>B</em>?</li>
<li>Do you think <em>NOUN</em> is important?</li>
<li>Which <em>NOUN</em> is popular in your country?</li>
</ul>
]]></content>
      <categories>
        <category>IELTS</category>
      </categories>
      <tags>
        <tag>IELTS</tag>
        <tag>English</tag>
      </tags>
  </entry>
</search>
