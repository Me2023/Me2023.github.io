<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LaTeX 代码备忘</title>
    <url>/2022/11/09/LaTeX%E4%BB%A3%E7%A0%81%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h1 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h1><h2 id="括号、矩阵相关"><a href="#括号、矩阵相关" class="headerlink" title="括号、矩阵相关"></a>括号、矩阵相关</h2><ol>
<li><p>花括号 $\lbrace A \rbrace$</p>
</li>
<li><p>大括号<br>注意，在MathJax，“\”需要替换为“\\”。<br> $$<br> m_{ij}&#x3D;\left\lbrace<br> \begin{aligned}<br> 1 &amp; , &amp; \text{if }(a_i, b_j)\in R, \\<br> 0 &amp; , &amp; \text{if }(a_i, b_j)\notin R.<br> \end{aligned}<br> \right.<br> $$</p>
</li>
<li><p>矩阵<br> $$<br> \begin{matrix} 0 &amp; 1 \\ 1 &amp; 0 \end{matrix}<br> \quad<br> \begin{pmatrix} 0 &amp; -i \\ i &amp; 0 \end{pmatrix}<br> \quad<br> \begin{bmatrix} 0 &amp; -1 \\ 1 &amp; 0 \end{bmatrix}<br> \quad<br> \begin{Bmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{Bmatrix}<br> \quad<br> \begin{vmatrix} a &amp; b \\ c &amp; d \end{vmatrix}<br> \quad<br> \begin{Vmatrix} i &amp; 0 \\ 0 &amp; -i \end{Vmatrix}<br> $$</p>
</li>
</ol>
<h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><ol>
<li>无穷 $\infty$</li>
</ol>
<h2 id="双目运算符"><a href="#双目运算符" class="headerlink" title="双目运算符"></a>双目运算符</h2><ol>
<li>关系运算符</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>$≤$</td>
<td>\leq</td>
<td>$≠$</td>
<td>\neq</td>
<td>$≈$</td>
<td>\approx</td>
<td>$∣$</td>
<td>\mid</td>
</tr>
<tr>
<td>$≥$</td>
<td>\geq</td>
<td>$≐$</td>
<td>\doteq</td>
<td>$≅$</td>
<td>\cong</td>
<td>$∥$</td>
<td>\parallel</td>
</tr>
<tr>
<td>$≪$</td>
<td>\ll</td>
<td>$∼$</td>
<td>\sim</td>
<td>$≡$</td>
<td>\equiv</td>
<td>$∝$</td>
<td>\propto</td>
</tr>
<tr>
<td>$≫$</td>
<td>\gg</td>
<td>$≃$</td>
<td>\simeq</td>
<td>$⊥$</td>
<td>\perp</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li>$a\ \cancel{R} \ a$</li>
</ol>
<h2 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h2><ol>
<li>花体字母：$\mathbb{R} \quad \mathcal{R} \quad \mathscr{R}$</li>
</ol>
]]></content>
      <categories>
        <category>编程语言/工具</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>修改日志</title>
    <url>/2022/11/10/%E4%BF%AE%E6%94%B9%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><h2 id="更改页面透明度"><a href="#更改页面透明度" class="headerlink" title="更改页面透明度"></a>更改页面透明度</h2><p><code>themes\next\source\css\variables\base.styl</code>53行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$body-bg-color                = white;</span><br><span class="line">$content-bg-color-dark        = $black-dim;</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$body-bg-color                = rgba(255,255,255,0.7);</span><br><span class="line">$content-bg-color-dark        = rgba(60,60,60,0.75);</span><br></pre></td></tr></table></figure>
<h2 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h2><p><code>themes\next\source\css\variables\Pisces.styl</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$body-bg-color                = #f5f7f9;</span><br></pre></td></tr></table></figure>
<p>更改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$body-bg-color                = rgba(250,210,225,0.2);</span><br></pre></td></tr></table></figure>
<p>以图片做背景后无效了。</p>
<h2 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h2><p><code>source\_data\variables.styl</code></p>
<h1 id="功能增加"><a href="#功能增加" class="headerlink" title="功能增加"></a>功能增加</h1><h2 id="最近文章"><a href="#最近文章" class="headerlink" title="最近文章"></a>最近文章</h2><p><code>themes\next\_config.yml</code>31行之后增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">recent_posts:</span><br><span class="line"># 块标题</span><br><span class="line">  title: 最近文章</span><br><span class="line"># 图标</span><br><span class="line">  icon: fa fa-history</span><br><span class="line"># 最多多少文章链接</span><br><span class="line">  max_count: 5</span><br></pre></td></tr></table></figure>
<p><code>source\_data\sidebar.njk</code>，<code>source\_data\styles.styl</code></p>
]]></content>
  </entry>
  <entry>
    <title>关系和有向图 Relations and Digraphs</title>
    <url>/2022/11/10/%E5%85%B3%E7%B3%BB%E5%92%8C%E6%9C%89%E5%90%91%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="笛卡尔积-product-set-x2F-Cartesian-product"><a href="#笛卡尔积-product-set-x2F-Cartesian-product" class="headerlink" title="笛卡尔积 (product set&#x2F;Cartesian product)"></a><strong>笛卡尔积</strong> <em>(product set&#x2F;Cartesian product)</em></h2><ul>
<li>$A \times B &#x3D; \left\lbrace(a,b)|a\in A\  and \  b \in B\right\rbrace$</li>
</ul>
<h2 id="划分-partiton-x2F-quotient-set"><a href="#划分-partiton-x2F-quotient-set" class="headerlink" title="划分 (partiton&#x2F;quotient set)"></a><strong>划分</strong> <em>(partiton&#x2F;quotient set)</em></h2><span id="more"></span>

<h2 id="关系-relation"><a href="#关系-relation" class="headerlink" title="关系 (relation)"></a><strong>关系</strong> <em>(relation)</em></h2><ul>
<li>A <strong>relation</strong> $R$ from $A$ to $B$ is a subset of $A\times B$. </li>
<li>If $R\subseteq A\times B$ and $(a,b)\in R$, we say that $a$ <strong>is related to</strong> $b$ <strong>by</strong> $R$, and we also write $a\ R\ b$.</li>
<li>$R\subseteq A\times A$ <strong>is a relation on</strong> $A$.</li>
<li><strong>$R$-relative set of</strong> $x$: $R(x) &#x3D; \lbrace y\in B | x\ R\  y\rbrace$.</li>
<li><strong>$R$-relative set of</strong> $A_1\subseteq A$: $R(A_1) &#x3D; \lbrace y\in B | x\ R\  y$ for some $x$ in $A_1$$\rbrace$.<ul>
<li><em>Theorem 1:</em><ul>
<li>If $A_1\subseteq A_2$, then $R(A_1)\subseteq R(A_2)$.</li>
<li>$R(A_1\cup A_2)&#x3D; R(A_1)\cup R(A_2)$</li>
<li>$R(A_1\cap A_2)\subseteq R(A_1)\cap R(A_2)$</li>
</ul>
</li>
<li><em>Theorem 2:</em> Let $R$ and $S$ be relations from A to B. If $R(a)&#x3D;S(a)$ for all $a$ in $A$, then $R&#x3D; S$.</li>
</ul>
</li>
<li><strong>关系矩阵</strong> matrix of a relation: $A&#x3D;\lbrace a_1, a_2, …, a_m\rbrace$ and $B&#x3D;\lbrace a_1, a_2, …, a_m\rbrace$ are finite sets, and $R$ is a relation from $A$ to $B$, we represent $R$ by the $m\times n$ matrix $M_R&#x3D;[m_{ij}]$, which is defined by<br>  $$<br>  m_{ij}&#x3D;\left\lbrace<br>  \begin{aligned}<br>  1 &amp;  &amp; \text{if }(a_i, b_j)\in R, \\<br>  0 &amp;  &amp; \text{if }(a_i, b_j)\notin R.<br>  \end{aligned}<br>  \right.<br>  $$<br>  The matrix $M_R$ is called the <strong>matrix of</strong> $R$.</li>
</ul>
<h2 id="有向图-digraphs-x2F-directed-graph"><a href="#有向图-digraphs-x2F-directed-graph" class="headerlink" title="有向图 (digraphs&#x2F;directed graph)"></a><strong>有向图</strong> <em>(digraphs&#x2F;directed graph)</em></h2><ul>
<li>vertices, edge, in-degree, out-degree</li>
</ul>
<h2 id="路径-path"><a href="#路径-path" class="headerlink" title="路径 (path)"></a><strong>路径</strong> <em>(path)</em></h2><ul>
<li>A path of length n in $R$ from $a$ to $b$ is a finite sequence $\pi:a,x_1x_2,…x_{n-1},b$, beginning with $a$ and ending with $b$, such that $a\ R\ x_1,\ x_1\ R\ x_2,\ …,\ x_{n-1}\ R\ b$.</li>
<li>If $n$ is a fixed positive integer, $x\ R^n\ y$ means that there is a path of length $n$ from $x$ to $y$ in $R$.<ul>
<li>$R^\infty$ is sometimes called the <strong>connectivity relation</strong> for $R$.</li>
<li><em>Theorem 1:</em> If $R$ is a relation on $A&#x3D;\lbrace a_1,a_2,…,a_n\rbrace$, then $M_{R^2}&#x3D;M_R\odot M_R$.</li>
<li><em>Theorem 2:</em> For $n\geq 2$ and $R$ a relation on a finite set $A$, we have $$M_{R^n}&#x3D;M_R\odot M_R\odot … \odot M_R\quad (n\text{ factors}).$$</li>
</ul>
</li>
</ul>
<h1 id="关系的特性"><a href="#关系的特性" class="headerlink" title="关系的特性"></a>关系的特性</h1><h2 id="自反性-reflexive-and-irreflexive"><a href="#自反性-reflexive-and-irreflexive" class="headerlink" title="自反性 (reflexive and irreflexive)"></a>自反性 <em>(reflexive and irreflexive)</em></h2><ul>
<li>A relation $R$ on a set $A$ is <strong>reflexive</strong> if $(a,a)\in R$ for all $a\in A$, that is, if $a\ R\ a$ for all $a \in A$.<ul>
<li>关系矩阵对角线上所有元素值都为1。</li>
</ul>
</li>
<li>A relation $R$ on a set $A$ is <strong>irreflexive</strong> if $a\ \cancel{R} \ a$ for all $a \in A$.<ul>
<li>关系矩阵对角线上所有元素值都为0。</li>
</ul>
</li>
</ul>
<h2 id="对称性-symmetric-asymmetric-and-antisymmetric"><a href="#对称性-symmetric-asymmetric-and-antisymmetric" class="headerlink" title="对称性 (symmetric, asymmetric and antisymmetric)"></a>对称性 <em>(symmetric, asymmetric and antisymmetric)</em></h2><ul>
<li>对称 A relation $R$ on a set $A$ is <strong>symmetric</strong> if whenever $a\ R \ b$, then $b\ R\ a$.<ul>
<li>关系矩阵是对称矩阵。</li>
</ul>
</li>
<li>非对称 A relation $R$ on a set $A$ is <strong>asymmetric</strong> if whenever $a\ R \ b$, then $b\ \cancel{R}\ a$.<ul>
<li>关系矩阵对角线全为0；关于对角线对称的元素值不能全为1。</li>
</ul>
</li>
<li>反对称 A relation $R$ on a set $A$ is <strong>antisymmetric</strong> if whenever $a\ R \ b$ and $b\ R \ a$, then $a&#x3D;b$. <ul>
<li>关系矩阵对角线不限制；除对角线外，关于对角线对称的元素值不能全为1。</li>
</ul>
</li>
</ul>
<h2 id="传递性-transitive"><a href="#传递性-transitive" class="headerlink" title="传递性 (transitive)"></a>传递性 <em>(transitive)</em></h2><ul>
<li>A relation $R$ on a set $A$ is <strong>transitive</strong> if whenever $a\ R \ b$ and $b\ R \ c$, then $a\ R\ c$.<ul>
<li><em>Theorem 1:</em> A relation $R$ is transitive iff $R^n\subseteq R$ for all $n\geq 1$.</li>
<li><em>Theorem 2:</em> in terms of $R$-relative sets<ul>
<li>Reflexivity of $R$ means that $a\in R(a)$ for all $a$ in $A$.</li>
<li>Symmetry of $R$ means that $a\in R(b)$ iff $b\in R(a)$.</li>
<li>Transitivity of $R$ means that if $b\in R(a)$ and $c\in R(b)$, then $c\in R(a)$.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="等价关系-equivalence-relation"><a href="#等价关系-equivalence-relation" class="headerlink" title="等价关系 (equivalence relation)"></a>等价关系 <em>(equivalence relation)</em></h2><ul>
<li>A relation $R$ on a set $A$ is called an <strong>equivalence relation</strong> if it is reflexive, symmetric, and transitive.<ul>
<li><em>Theorem 1:</em> Let $\mathcal{P}$ be a partition of a set $A$ (Sets in $\mathcal{P}$ are called the blocks of $\mathcal{P}$). Define the relation $R$ on $A$ as follows:<br>$$<br>a\ R\ b\qquad \text{iff $a$ and $b$ are members of the same block.}<br>$$<br>Then $R$ is an equivalence relation on $A$.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CS 相关数理基础</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 图和网络算法（一）基本函数</title>
    <url>/2022/11/11/%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>主要参考MATLAB官方帮助文档：<br><a href="https://ww2.mathworks.cn/help/matlab/graph-and-network-algorithms_zh_CN.html">https://ww2.mathworks.cn/help/matlab/graph-and-network-algorithms_zh_CN.html</a></p>
<h1 id="创建、查询、修改图"><a href="#创建、查询、修改图" class="headerlink" title="创建、查询、修改图"></a>创建、查询、修改图</h1><p>图的绘图非自带函数，需要 <code>plot(g)</code> ，并在括号中设置 <code>&#39;options&#39;</code> 即可。其中，是否显示每条边的权值，由 <code>&#39;EdgeLabelMode&#39;</code> 设置。</p>
<h2 id="创建图"><a href="#创建图" class="headerlink" title="创建图"></a>创建图</h2><h3 id="邻接矩阵（关系矩阵）绘图"><a href="#邻接矩阵（关系矩阵）绘图" class="headerlink" title="邻接矩阵（关系矩阵）绘图"></a>邻接矩阵（关系矩阵）绘图</h3><p>使用邻接矩阵通过 <code>graph</code> 或 <code>digraph</code> 函数来创建图。反之，可以使用 <code>adjacency</code> 函数求预先存在的图的加权或未加权的稀疏邻接矩阵。</p>
<ol>
<li><p>创建无向图：必须是对称矩阵。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">g1 = [<span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;</span><br><span class="line">      <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">      <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">      <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">G = graph(g1); </span><br></pre></td></tr></table></figure>
<img src="/2022/11/11/%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/image1.png" class="" title="无向图">
</li>
<li><p>创建有向图：可以不是对称矩阵。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">MR = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">      <span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">      <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span>;</span><br><span class="line">      <span class="number">8</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">dG = digraph(MR); </span><br></pre></td></tr></table></figure>
<img src="/2022/11/11/%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/image2.png" class="" title="有向带权图"></li>
</ol>
<h3 id="边列表绘图"><a href="#边列表绘图" class="headerlink" title="边列表绘图"></a>边列表绘图</h3><p>对于稀疏矩阵和多重图（邻接矩阵无法表示多重图），列出所有边的边列表是更好的选择。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">source_nodes = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line">target_nodes = &#123;<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line">edge_weights = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>];</span><br><span class="line">G1 = graph(source_nodes, target_nodes, edge_weights);</span><br><span class="line">G2 = digraph(source_nodes, target_nodes, edge_weights);</span><br></pre></td></tr></table></figure>

<h2 id="图节点ID和高亮"><a href="#图节点ID和高亮" class="headerlink" title="图节点ID和高亮"></a>图节点ID和高亮</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>; <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>; <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">G = graph(A, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;);</span><br><span class="line">p = shortestpath(G, <span class="number">1</span>, <span class="number">4</span>)                     <span class="comment">% p = 1 3 4</span></span><br><span class="line">p1 = shortestpath(G, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)                <span class="comment">% p = &#123;&#x27;a&#x27;&#125; &#123;&#x27;c&#x27;&#125; &#123;&#x27;d&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>用数据结构课上 Dijkstra 算法例子里的图小小试一下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">source_nodes = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span>] + <span class="number">1</span>;</span><br><span class="line">target_nodes = [<span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">4</span>] + <span class="number">1</span>;</span><br><span class="line">edge_weights = [<span class="number">10</span> <span class="number">30</span> <span class="number">100</span> <span class="number">50</span> <span class="number">10</span> <span class="number">20</span> <span class="number">60</span>];</span><br><span class="line">G = digraph(source_nodes, target_nodes, edge_weights);</span><br><span class="line">H = plotDigraph(G);</span><br><span class="line">p = shortestpath(G, <span class="number">1</span>, <span class="number">5</span>)                     <span class="comment">% p = 1 4 3 5</span></span><br><span class="line"><span class="comment">% 突出显示最短路径</span></span><br><span class="line">highlight(H, p, <span class="string">&#x27;EdgeColor&#x27;</span>,[<span class="number">255</span> <span class="number">127</span> <span class="number">80</span>]/<span class="number">255</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>) </span><br></pre></td></tr></table></figure>
<img src="/2022/11/11/%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95/image5.png" class="" title="最短路径高亮">]]></content>
      <categories>
        <category>编程语言/工具</category>
      </categories>
      <tags>
        <tag>图论算法</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 动态内存分配</title>
    <url>/2022/11/12/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C 内存管理"></a>C 内存管理</h1><p>在程序的执行期间经常需要动态分配内存。</p>
<p>具体表现有在<em>函数体内声明</em>了一个变量、结构体或数组等，这样的内存是分配是由系统操作分配在<strong>栈</strong>上的，在执行完函数后，函数体内开头所声明的变量、结构体或数组所持有的内存空间都会被释放。所以要将函数体内的执行结果返回或反映到函数体外，一般是行不通的(不考虑全局变量)。</p>
<p>还有一种是由coder们调用malloc()等内存分配函数在<strong>堆</strong>上开辟新内存块，这些内存块会一起存在直至调用 <code>free()</code> 函数去释放。作用域广了，但也引入了潜在的内存泄露(程序卡顿)和野指针(程序crash)问题。</p>
<ul>
<li>很多时候，我们无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。这时便需要动态分配内存。（但现在 C&#x2F;C++ 已经支持用变量定义数组长度了）</li>
</ul>
<h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">int</span> size)</span>; 和 <span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>malloc</code>: 在内存的动态存储区（堆区）分配 1 块长度为 size 的内存空间。返回该区域首地址。</li>
<li><code>calloc</code>: 在内存的动态存储区（堆区）分配 num 块长度为 size 的内存空间，并将每一个字节都<em>初始化</em>为 0。返回该区域首地址。<br>这些函数可以在 <code>&lt;stdlib.h&gt;</code> 头文件中找到。<br>它们返回的是 void * 类型，也就是说，如果我们要为 int 或者其他类型的数据分配空间，必须显式强制转换。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * ip_a;</span><br><span class="line">ip_a = (<span class="type">int</span> *)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (<span class="type">int</span>) * <span class="number">5</span> );</span><br><span class="line">或</span><br><span class="line">ip_a = (<span class="type">int</span> *)<span class="built_in">calloc</span>( <span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) );</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="重新调整内存的大小、释放内存"><a href="#重新调整内存的大小、释放内存" class="headerlink" title="重新调整内存的大小、释放内存"></a>重新调整内存的大小、释放内存</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *address, <span class="type">int</span> newsize)</span>; 和 	<span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>在不需要该内存时，都应调用函数 <code>free()</code> 来释放。</p>
<h2 id="示例：动态数组的定义和使用"><a href="#示例：动态数组的定义和使用" class="headerlink" title="示例：动态数组的定义和使用"></a>示例：动态数组的定义和使用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义动态数组指针，动态分配数组空间</span></span><br><span class="line">    <span class="type">int</span> *A, *T;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    A = (<span class="type">int</span> *)<span class="built_in">malloc</span>( n * <span class="keyword">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;存储分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用指针直接存</span></span><br><span class="line">    T = A;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n<span class="number">-2</span>; i++) &#123;</span><br><span class="line">        *T = i + <span class="number">1</span>;</span><br><span class="line">        T++;</span><br><span class="line">    &#125;</span><br><span class="line">    *T = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用指针直接取</span></span><br><span class="line">    T = A;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *T);</span><br><span class="line">        T++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态释放数组空间</span></span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-内存管理-1"><a href="#C-内存管理-1" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h1><h2 id="new-和-delete-运算符"><a href="#new-和-delete-运算符" class="headerlink" title="new 和 delete 运算符"></a><code>new</code> 和 <code>delete</code> 运算符</h2><p>在 C++ 中，使用 <code>new</code> 运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。 如果未成功，<code>new</code> 将返回 0 或引发异常。</p>
<p><code>delete</code> 运算符删除之前由 <code>new</code> 运算符分配的内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="type">double</span>;   <span class="comment">// 为变量请求内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理异常</span></span><br><span class="line"><span class="type">double</span>* pvalue  = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>( !(pvalue  = <span class="keyword">new</span> <span class="type">double</span> ))</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Error: out of memory.&quot;</span> &lt;&lt;endl;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pvalue;          <span class="comment">// 释放 pvalue 所指向的内存</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的动态内存分配"><a href="#数组的动态内存分配" class="headerlink" title="数组的动态内存分配"></a>数组的动态内存分配</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* pvalue  = <span class="literal">NULL</span>;   <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>]; <span class="comment">// 为变量请求内存</span></span><br><span class="line"><span class="keyword">delete</span> [] pvalue;       <span class="comment">// 删除 pvalue 所指向的数组</span></span><br></pre></td></tr></table></figure>

<h2 id="示例：分配和释放字符数组"><a href="#示例：分配和释放字符数组" class="headerlink" title="示例：分配和释放字符数组"></a>示例：分配和释放字符数组</h2><p>下面的代码示例分配类 <code>CName</code> 的一个字符数组和一个对象，然后释放它们。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">enum</span> &#123;</span><br><span class="line">      sizeOfBuffer = <span class="number">256</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> m_szFirst[sizeOfBuffer];</span><br><span class="line">   <span class="type">char</span> m_szLast[sizeOfBuffer];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(<span class="type">char</span>* pszFirst, <span class="type">char</span>* pszLast)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">strcpy_s</span>(m_szFirst, sizeOfBuffer, pszFirst);</span><br><span class="line">     <span class="built_in">strcpy_s</span>(m_szLast, sizeOfBuffer, pszLast);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Allocate memory for the array</span></span><br><span class="line">   <span class="type">char</span>* pCharArray = <span class="keyword">new</span> <span class="type">char</span>[CName::sizeOfBuffer];</span><br><span class="line">   <span class="built_in">strcpy_s</span>(pCharArray, CName::sizeOfBuffer, <span class="string">&quot;Array of characters&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Deallocate memory for the array</span></span><br><span class="line">   <span class="keyword">delete</span> [] pCharArray;</span><br><span class="line">   pCharArray = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allocate memory for the object</span></span><br><span class="line">   CName* pName = <span class="keyword">new</span> CName;</span><br><span class="line">   pName-&gt;<span class="built_in">SetName</span>(<span class="string">&quot;Firstname&quot;</span>, <span class="string">&quot;Lastname&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Deallocate memory for the object</span></span><br><span class="line">   <span class="keyword">delete</span> pName;</span><br><span class="line">   pName = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例：对使用-new-分配的对象进行初始化"><a href="#示例：对使用-new-分配的对象进行初始化" class="headerlink" title="示例：对使用 new 分配的对象进行初始化"></a>示例：对使用 <code>new</code> 分配的对象进行初始化</h2><p>以下示例说明了如何将初始化表达式与 <code>new</code> 运算符配合使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Acct</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Define default constructor and a constructor that accepts</span></span><br><span class="line">    <span class="comment">//  an initial balance.</span></span><br><span class="line">    <span class="built_in">Acct</span>() &#123;</span><br><span class="line">        balance = <span class="number">0.0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Acct</span>( <span class="type">double</span> init_balance ) &#123; </span><br><span class="line">        balance = init_balance; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Acct *CheckingAcct = <span class="keyword">new</span> Acct;</span><br><span class="line">    Acct *SavingsAcct = <span class="keyword">new</span> <span class="built_in">Acct</span> ( <span class="number">34.98</span> );</span><br><span class="line">    <span class="type">double</span> *HowMuch = <span class="keyword">new</span> <span class="type">double</span> &#123; <span class="number">43.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言/工具</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：多维数组和广义表</title>
    <url>/2022/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CS 专业基础课</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
